import{_ as a,c as e,o as t,a5 as i,b9 as l,ba as o,bb as r}from"./chunks/framework.DDBsw1uY.js";const v=JSON.parse('{"title":"移动端","description":"","frontmatter":{},"headers":[],"relativePath":"前端/javascript/移动端.md","filePath":"前端/javascript/移动端.md","lastUpdated":1718961612000}'),s={name:"前端/javascript/移动端.md"},h=i('<h1 id="移动端" tabindex="-1">移动端 <a class="header-anchor" href="#移动端" aria-label="Permalink to &quot;移动端&quot;">​</a></h1><h2 id="_1、基础" tabindex="-1">1、基础 <a class="header-anchor" href="#_1、基础" aria-label="Permalink to &quot;1、基础&quot;">​</a></h2><h4 id="调试方法" tabindex="-1">调试方法 <a class="header-anchor" href="#调试方法" aria-label="Permalink to &quot;调试方法&quot;">​</a></h4><ul><li>谷歌浏览器的模拟手机调试</li><li>搭建本地web服务器，手机和服务器一个局域网内，通过手机访问服务器</li><li>使用外网服务器，直接ip或域名访问</li></ul><h2 id="_2、视口" tabindex="-1">2、视口 <a class="header-anchor" href="#_2、视口" aria-label="Permalink to &quot;2、视口&quot;">​</a></h2><h4 id="_1、布局视口-layout-viewport" tabindex="-1">1、布局视口 layout viewport <a class="header-anchor" href="#_1、布局视口-layout-viewport" aria-label="Permalink to &quot;1、布局视口 layout viewport&quot;">​</a></h4><p>分辨率设置为980px</p><p>一般不用</p><h3 id="_2、视觉视口-visual-viewport" tabindex="-1">2、视觉视口 visual viewport <a class="header-anchor" href="#_2、视觉视口-visual-viewport" aria-label="Permalink to &quot;2、视觉视口 visual viewport&quot;">​</a></h3><h3 id="_3、理想视口-ideal-viewport" tabindex="-1">3、理想视口 ideal viewport <a class="header-anchor" href="#_3、理想视口-ideal-viewport" aria-label="Permalink to &quot;3、理想视口 ideal viewport&quot;">​</a></h3><p>手动添加meta视口标签通知浏览器操作</p><h4 id="meta视口标签" tabindex="-1">meta视口标签 <a class="header-anchor" href="#meta视口标签" aria-label="Permalink to &quot;meta视口标签&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;meta name=&quot;&quot; content=&quot;width=device-width&quot; &gt;</span></span></code></pre></div><p><img src="'+l+'" alt="image-20221103211738488" loading="lazy"></p><h2 id="_3、移动端开发旋转" tabindex="-1">3、移动端开发旋转 <a class="header-anchor" href="#_3、移动端开发旋转" aria-label="Permalink to &quot;3、移动端开发旋转&quot;">​</a></h2><ul><li><p>单独移动端页面——通常情况下，网址域名前家m（mobile）可以打开移动端。通过判断设备，如果是移动端设备打开，则跳转到移动端页面。</p><p>流式布局、felx弹性布局、less+rem+媒体查询布局、混合布局</p></li><li><p>响应式兼容PC移动端——通过判断屏幕宽度来改变样式，以适应不同终端。</p><p>媒体布局、bootstartp</p></li></ul><h1 id="响应式开发" tabindex="-1">响应式开发 <a class="header-anchor" href="#响应式开发" aria-label="Permalink to &quot;响应式开发&quot;">​</a></h1><h3 id="_1、响应式开发" tabindex="-1">1、响应式开发 <a class="header-anchor" href="#_1、响应式开发" aria-label="Permalink to &quot;1、响应式开发&quot;">​</a></h3><p>就是使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的</p><p><img src="'+o+'" alt="image-20221105152200470" loading="lazy"></p><h3 id="_2、响应式布局容器" tabindex="-1">2、响应式布局容器 <a class="header-anchor" href="#_2、响应式布局容器" aria-label="Permalink to &quot;2、响应式布局容器&quot;">​</a></h3><ul><li>响应式需要一个父级做为布局容器，来配合子级元素来实现变化效果</li><li>原理就是在不同屏幕下，通过媒体查询来改变或者布局容器的大小，再改变里面子元素的排列方式和大小，从而实现不同屏幕下，看到不同的页面布局和样式变化</li></ul><p><img src="'+r+'" alt="image-20221105152520284" loading="lazy"></p>',23),n=[h];function d(p,c,u,_,m,b){return t(),e("div",null,n)}const f=a(s,[["render",d]]);export{v as __pageData,f as default};
