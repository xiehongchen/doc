<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>xiehongchen | 记录学习过程的问题</title>
    <meta name="description" content="基于 VitePress 构建的个人博客网站">
    <meta name="generator" content="VitePress v1.2.2">
    <link rel="preload stylesheet" href="/doc/assets/style.DV0yjjkx.css" as="style">
    
    <script type="module" src="/doc/assets/app.4Owz2rI-.js"></script>
    <link rel="preload" href="/doc/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/doc/assets/chunks/framework.g1bUz4ZK.js">
    <link rel="modulepreload" href="/doc/assets/chunks/theme.BVvcJdiQ.js">
    <link rel="modulepreload" href="/doc/assets/前端_vue_index.md.Cp3HWG8L.lean.js">
    <link rel="icon" href="/doc/logo.jpeg">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
    <link rel="manifest" href="/doc/manifest.webmanifest">
    <script id="vite-plugin-pwa:register-sw" src="/doc/registerSW.js"></script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-403ff2a5><!--[--><!--]--><!--[--><span tabindex="-1" data-v-680918f4></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-680918f4> Skip to content </a><!--]--><!----><header class="VPNav" data-v-403ff2a5 data-v-68a59984><div class="VPNavBar has-sidebar top" data-v-68a59984 data-v-cead1e5a><div class="wrapper" data-v-cead1e5a><div class="container" data-v-cead1e5a><div class="title" data-v-cead1e5a><div class="VPNavBarTitle has-sidebar" data-v-cead1e5a data-v-25565f7c><a class="title" href="/doc/" data-v-25565f7c><!--[--><!--]--><!--[--><img class="VPImage logo" src="/doc/logo.jpeg" alt data-v-5eff603d><!--]--><span data-v-25565f7c>xiehongchen</span><!--[--><!--]--></a></div></div><div class="content" data-v-cead1e5a><div class="content-body" data-v-cead1e5a><!--[--><!--]--><div class="VPNavBarSearch search" data-v-cead1e5a><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-cead1e5a data-v-3c119136><span id="main-nav-aria-label" class="visually-hidden" data-v-3c119136>Main Navigation</span><!--[--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-3c119136 data-v-3e511869><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-3e511869><span class="text" data-v-3e511869><!----><span data-v-3e511869>前端基础</span><span class="vpi-chevron-down text-icon" data-v-3e511869></span></span></button><div class="menu" data-v-3e511869><div class="VPMenu" data-v-3e511869 data-v-349ff643><div class="items" data-v-349ff643><!--[--><!--[--><div class="VPMenuLink" data-v-349ff643 data-v-50a3748c><a class="VPLink link" href="/doc/前端/html/" data-v-50a3748c><!--[-->HTML<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-349ff643 data-v-50a3748c><a class="VPLink link" href="/doc/前端/css/" data-v-50a3748c><!--[-->CSS<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-349ff643 data-v-50a3748c><a class="VPLink link" href="/doc/前端/javascript/" data-v-50a3748c><!--[-->JavaScript<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup active" data-v-3c119136 data-v-3e511869><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-3e511869><span class="text" data-v-3e511869><!----><span data-v-3e511869>前端进阶</span><span class="vpi-chevron-down text-icon" data-v-3e511869></span></span></button><div class="menu" data-v-3e511869><div class="VPMenu" data-v-3e511869 data-v-349ff643><div class="items" data-v-349ff643><!--[--><!--[--><div class="VPMenuLink" data-v-349ff643 data-v-50a3748c><a class="VPLink link" href="/doc/前端/typescript/" data-v-50a3748c><!--[-->TypeScript<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-349ff643 data-v-50a3748c><a class="VPLink link active" href="/doc/前端/vue/" data-v-50a3748c><!--[-->Vue<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-349ff643 data-v-50a3748c><a class="VPLink link" href="/doc/前端/react/" data-v-50a3748c><!--[-->React<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/doc/%E5%85%B6%E4%BB%96" tabindex="0" data-v-3c119136 data-v-6453e2b6><!--[--><span data-v-6453e2b6>其他</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/doc/%E7%AE%97%E6%B3%95" tabindex="0" data-v-3c119136 data-v-6453e2b6><!--[--><span data-v-6453e2b6>算法</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-3c119136 data-v-3e511869><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-3e511869><span class="text" data-v-3e511869><!----><span data-v-3e511869>后端</span><span class="vpi-chevron-down text-icon" data-v-3e511869></span></span></button><div class="menu" data-v-3e511869><div class="VPMenu" data-v-3e511869 data-v-349ff643><div class="items" data-v-349ff643><!--[--><!--[--><div class="VPMenuLink" data-v-349ff643 data-v-50a3748c><a class="VPLink link" href="/doc/后端/node/" data-v-50a3748c><!--[-->Node<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-349ff643 data-v-50a3748c><a class="VPLink link" href="/doc/后端/java/" data-v-50a3748c><!--[-->Java<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-cead1e5a data-v-a0911a6d><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-a0911a6d data-v-6300207d data-v-98e7137e><span class="check" data-v-98e7137e><span class="icon" data-v-98e7137e><!--[--><span class="vpi-sun sun" data-v-6300207d></span><span class="vpi-moon moon" data-v-6300207d></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-cead1e5a data-v-a0f395c6 data-v-6e264a5a><!--[--><a class="VPSocialLink no-icon" href="https://github.com/xiehongchen" aria-label="github" target="_blank" rel="noopener" data-v-6e264a5a data-v-614e0df3><span class="vpi-social-github" /></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-cead1e5a data-v-9e03bb26 data-v-3e511869><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-3e511869><span class="vpi-more-horizontal icon" data-v-3e511869></span></button><div class="menu" data-v-3e511869><div class="VPMenu" data-v-3e511869 data-v-349ff643><!----><!--[--><!--[--><!----><div class="group" data-v-9e03bb26><div class="item appearance" data-v-9e03bb26><p class="label" data-v-9e03bb26>Appearance</p><div class="appearance-action" data-v-9e03bb26><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-9e03bb26 data-v-6300207d data-v-98e7137e><span class="check" data-v-98e7137e><span class="icon" data-v-98e7137e><!--[--><span class="vpi-sun sun" data-v-6300207d></span><span class="vpi-moon moon" data-v-6300207d></span><!--]--></span></span></button></div></div></div><div class="group" data-v-9e03bb26><div class="item social-links" data-v-9e03bb26><div class="VPSocialLinks social-links-list" data-v-9e03bb26 data-v-6e264a5a><!--[--><a class="VPSocialLink no-icon" href="https://github.com/xiehongchen" aria-label="github" target="_blank" rel="noopener" data-v-6e264a5a data-v-614e0df3><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-cead1e5a data-v-21f8330f><span class="container" data-v-21f8330f><span class="top" data-v-21f8330f></span><span class="middle" data-v-21f8330f></span><span class="bottom" data-v-21f8330f></span></span></button></div></div></div></div><div class="divider" data-v-cead1e5a><div class="divider-line" data-v-cead1e5a></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-403ff2a5 data-v-1f683481><div class="container" data-v-1f683481><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-1f683481><span class="vpi-align-left menu-icon" data-v-1f683481></span><span class="menu-text" data-v-1f683481>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-1f683481 data-v-22391d46><button data-v-22391d46>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-403ff2a5 data-v-30f4eebd><div class="curtain" data-v-30f4eebd></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-30f4eebd><span class="visually-hidden" id="sidebar-aria-label" data-v-30f4eebd> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-30f4eebd><section class="VPSidebarItem level-0 has-active" data-v-30f4eebd data-v-ddec4601><!----><div class="items" data-v-ddec4601><!--[--><div class="VPSidebarItem level-1 is-link" data-v-ddec4601 data-v-ddec4601><div class="item" data-v-ddec4601><div class="indicator" data-v-ddec4601></div><a class="VPLink link link" href="/doc/%E5%89%8D%E7%AB%AF/vue/index" data-v-ddec4601><!--[--><p class="text" data-v-ddec4601>vue</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-ddec4601 data-v-ddec4601><div class="item" data-v-ddec4601><div class="indicator" data-v-ddec4601></div><a class="VPLink link link" href="/doc/%E5%89%8D%E7%AB%AF/vue/vue2" data-v-ddec4601><!--[--><p class="text" data-v-ddec4601>Vue2</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-30f4eebd><section class="VPSidebarItem level-0 collapsible collapsed" data-v-30f4eebd data-v-ddec4601><div class="item" role="button" tabindex="0" data-v-ddec4601><div class="indicator" data-v-ddec4601></div><h2 class="text" data-v-ddec4601>Vue3</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-ddec4601><span class="vpi-chevron-right caret-icon" data-v-ddec4601></span></div></div><div class="items" data-v-ddec4601><!--[--><div class="VPSidebarItem level-1 is-link" data-v-ddec4601 data-v-ddec4601><div class="item" data-v-ddec4601><div class="indicator" data-v-ddec4601></div><a class="VPLink link link" href="/doc/%E5%89%8D%E7%AB%AF/vue/vue3/1%E3%80%81%E5%88%9B%E5%BB%BAVue3.0%E5%B7%A5%E7%A8%8B" data-v-ddec4601><!--[--><p class="text" data-v-ddec4601>1、创建Vue3.0工程</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-ddec4601 data-v-ddec4601><div class="item" data-v-ddec4601><div class="indicator" data-v-ddec4601></div><a class="VPLink link link" href="/doc/%E5%89%8D%E7%AB%AF/vue/vue3/2%E3%80%81%E5%B8%B8%E7%94%A8%20Composition%20API" data-v-ddec4601><!--[--><p class="text" data-v-ddec4601>2、常用 Composition API</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-ddec4601 data-v-ddec4601><div class="item" data-v-ddec4601><div class="indicator" data-v-ddec4601></div><a class="VPLink link link" href="/doc/%E5%89%8D%E7%AB%AF/vue/vue3/3%E3%80%81%E5%85%B6%E5%AE%83%20Composition%20API" data-v-ddec4601><!--[--><p class="text" data-v-ddec4601>3、其它 Composition API</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-ddec4601 data-v-ddec4601><div class="item" data-v-ddec4601><div class="indicator" data-v-ddec4601></div><a class="VPLink link link" href="/doc/%E5%89%8D%E7%AB%AF/vue/vue3/4%E3%80%81Composition%20API%20%E7%9A%84%E4%BC%98%E5%8A%BF" data-v-ddec4601><!--[--><p class="text" data-v-ddec4601>4、Composition API 的优势</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-ddec4601 data-v-ddec4601><div class="item" data-v-ddec4601><div class="indicator" data-v-ddec4601></div><a class="VPLink link link" href="/doc/%E5%89%8D%E7%AB%AF/vue/vue3/5%E3%80%81%E6%96%B0%E7%9A%84%E7%BB%84%E4%BB%B6" data-v-ddec4601><!--[--><p class="text" data-v-ddec4601>5、新的组件</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-ddec4601 data-v-ddec4601><div class="item" data-v-ddec4601><div class="indicator" data-v-ddec4601></div><a class="VPLink link link" href="/doc/%E5%89%8D%E7%AB%AF/vue/vue3/6%E3%80%81%E5%85%B6%E4%BB%96" data-v-ddec4601><!--[--><p class="text" data-v-ddec4601>6、其他</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-403ff2a5 data-v-a631d57f><div class="VPDoc has-sidebar has-aside" data-v-a631d57f data-v-04d3a308><!--[--><!--]--><div class="container" data-v-04d3a308><div class="aside" data-v-04d3a308><div class="aside-curtain" data-v-04d3a308></div><div class="aside-container" data-v-04d3a308><div class="aside-content" data-v-04d3a308><div class="VPDocAside" data-v-04d3a308 data-v-8308ff81><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-8308ff81 data-v-176f70f5><div class="content" data-v-176f70f5><div class="outline-marker" data-v-176f70f5></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-176f70f5>当前页导航</div><ul class="VPDocOutlineItem root" data-v-176f70f5 data-v-8ce01372><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-8308ff81></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-04d3a308><div class="content-container" data-v-04d3a308><!--[--><!--]--><main class="main" data-v-04d3a308><div style="position:relative;" class="vp-doc _doc_%E5%89%8D%E7%AB%AF_vue_" data-v-04d3a308><div><h2 id="vue的优缺点" tabindex="-1">vue的优缺点 <a class="header-anchor" href="#vue的优缺点" aria-label="Permalink to &quot;vue的优缺点&quot;">​</a></h2><p>优点：渐进式，组件化，轻量级，虚拟dom，响应式，单页面路由，数据与视图分开</p><p>缺点：单页面不利于seo，不支持IE8以下，首屏加载时间长</p><h2 id="为什么data是个函数并且返回一个对象" tabindex="-1">为什么data是个函数并且返回一个对象 <a class="header-anchor" href="#为什么data是个函数并且返回一个对象" aria-label="Permalink to &quot;为什么data是个函数并且返回一个对象&quot;">​</a></h2><p><code>data</code>之所以是一个函数，是因为一个组件可能会多处调用，而每一次调用就会执行<code>data函数</code>并返回新的数据对象，这样，可以避免多处调用之间的<code>数据污染</code>。</p><h2 id="vue的修饰符" tabindex="-1">vue的修饰符 <a class="header-anchor" href="#vue的修饰符" aria-label="Permalink to &quot;vue的修饰符&quot;">​</a></h2><p><img src="https://kqd19315lhi.feishu.cn/space/api/box/stream/download/asynccode/?code=NGJhODhhODA0YWYxYjU4NWVkOTg4YWNiOTE4NTkyNjFfZksxQ3ZNdGRLZ3BxNk5JTVh2WUk1OVpPMnZxanVFM0JfVG9rZW46WFpuVmIycVpRb0RkM1B4aUZBVWN1OHBpbldiXzE3MTU2NTY4NDA6MTcxNTY2MDQ0MF9WNA" alt="img" loading="lazy"></p><h2 id="组件间通信" tabindex="-1">组件间通信 <a class="header-anchor" href="#组件间通信" aria-label="Permalink to &quot;组件间通信&quot;">​</a></h2><ul><li>使用ref <ul><li>获取子组件实例，通过子组件实例拿到数据</li></ul></li><li>状态管理库，vuex、pinia</li><li>父组件传值给子组件，子组件使用<code>props</code>进行接收</li><li>子组件传值给父组件，子组件使用<code>$emit+事件</code>对父组件进行传值</li><li>组件中可以使用<code>$parent</code>和<code>$children</code>获取到父组件实例和子组件实例，进而获取数据。通过共同祖辈<code>$parent</code>或者<code>$root</code>搭建通信桥梁</li></ul><div class="language-JavaScript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 兄弟组件</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$parent.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;add&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.add)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 兄弟组件</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$parent.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;add&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><ul><li>使用<code>$attrs</code>和<code>$listeners</code>，在对一些组件进行二次封装时可以方便传值，例如A-&gt;B-&gt;C</li><li>使用<code>$refs</code>获取组件实例，进而获取数据</li><li>使用<code>Vuex</code>进行状态管理</li><li>使用<code>eventBus</code>进行跨组件触发事件，进而传递数据。这个需要及时清除<code>$emit</code>，不然后续会触发多次，也就接受多次</li></ul><div class="language-JavaScript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 组件1，触发这个</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$bus.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 组件2，接受这个</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$bus.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">handle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 组件3，接受这个</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$bus.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">handle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><ul><li>使用<code>provide</code>和<code>inject</code>，官方建议我们不要用这个，我在看<code>ElementUI</code>源码时发现大量使用。祖先组件定义<code>provide</code>属性，返回传递的值，在后代组件通过<code>inject</code>接受组件传递过来的值</li></ul><div class="language-JavaScript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 祖先组件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">provide</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        foo: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 后代组件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><ul><li>使用浏览器本地缓存，例如<code>localStorage</code></li></ul><h2 id="vue的生命周期" tabindex="-1">vue的生命周期 <a class="header-anchor" href="#vue的生命周期" aria-label="Permalink to &quot;vue的生命周期&quot;">​</a></h2><p><img src="https://kqd19315lhi.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmUyZDQ3NTA5ZTU1MTE5ZDI3MmM3MTA5N2U4NDc1Y2RfeEtnUm14ems1cW04cktZWHFaekNmd3A4TVRiSkhxb1BfVG9rZW46RW9USGJHTWsyb0ROUXh4Tk8xWmNlSm1QbmFmXzE3MTU2NTY4NDA6MTcxNTY2MDQ0MF9WNA" alt="img" loading="lazy"></p><h2 id="为什么只对对象劫持-而要对数组进行方法重写" tabindex="-1">为什么只对对象劫持，而要对数组进行方法重写？ <a class="header-anchor" href="#为什么只对对象劫持-而要对数组进行方法重写" aria-label="Permalink to &quot;为什么只对对象劫持，而要对数组进行方法重写？&quot;">​</a></h2><p>因为对象最多也就几十个属性，拦截起来数量不多，但是数组可能会有几百几千项，拦截起来非常耗性能，所以直接重写数组原型上的方法，是比较节省性能的方案</p><h2 id="为什么要使用ref-函数来声明响应式状态" tabindex="-1">为什么要使用<code>ref()</code>函数来声明响应式状态 <a class="header-anchor" href="#为什么要使用ref-函数来声明响应式状态" aria-label="Permalink to &quot;为什么要使用`ref()`函数来声明响应式状态&quot;">​</a></h2><blockquote><p><strong><a href="https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#why-refs" target="_blank" rel="noreferrer">为什么要使用ref ?</a></strong></p></blockquote><blockquote><p>当你在模板中使用了一个 ref，然后改变了这个 ref 的值时，Vue 会自动检测到这个变化，并且相应地更新 DOM。这是通过一个基于依赖追踪的响应式系统实现的。当一个组件首次渲染时，Vue 会<strong>追踪</strong>在渲染过程中使用的每一个 ref。然后，当一个 ref 被修改时，它会<strong>触发</strong>追踪它的组件的一次重新渲染。</p></blockquote><blockquote><p>在标准的 JavaScript 中，检测普通变量的访问或修改是行不通的。然而，我们可以通过 getter 和 setter 方法来拦截对象属性的 get 和 set 操作。</p></blockquote><blockquote><p>该 <code>.value</code> 属性给予了 Vue 一个机会来检测 ref 何时被访问或修改。在其内部，Vue 在它的 getter 中执行追踪，在它的 setter 中执行触发。从概念上讲，你可以将 ref 看作是一个像这样的对象：</p></blockquote><div class="language-JavaScript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 伪代码，不是真正的实现</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">_value: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">get</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">track</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._value</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">set</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newValue</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">trigger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>另一个 ref 的好处是，与普通变量不同，你可以将 ref 传递给函数，同时保留对最新值和响应式连接的访问。当将复杂的逻辑重构为可重用的代码时，这将非常有用。</p></blockquote><h2 id="computed和watch、watcheffect" tabindex="-1">computed和watch、watchEffect <a class="header-anchor" href="#computed和watch、watcheffect" aria-label="Permalink to &quot;computed和watch、watchEffect&quot;">​</a></h2><table><thead><tr><th>对比依据</th><th>computed</th><th>watch</th><th>watchEffect</th></tr></thead><tbody><tr><td>是否自动收集依赖（1）</td><td>自动</td><td>需要指定依赖对象</td><td>自动</td></tr><tr><td>有无返回值</td><td>有</td><td>无</td><td>有</td></tr><tr><td>是否可以赋值</td><td>可以</td><td>不能</td><td>不能</td></tr><tr><td>使用场景</td><td>简单情况</td><td>复杂情况</td><td>简单情况</td></tr><tr><td>是否立即执行</td><td>是</td><td>看参数（2）</td><td>是</td></tr><tr><td>本质</td><td>class</td><td>function</td><td>function</td></tr></tbody></table><p>（1）依赖：指的是响应性依赖，也就是侦听 ref、reactive 这类具有响应性的对象。</p><p>（2）watch：默认情况下，被侦听对象变化时才会执行，但是可以通过 options 参数设置为可以立即执行</p><blockquote><p>computed的缓存原理：就是ComputedRefImpl上有私有成员<code>_value</code>，执行get方法时，会吧返回值存入<code>_value</code>，template直接从<code>_value</code>属性获取数据，在需要更新缓存的时候才会调用<code>getter</code>方法</p></blockquote><h2 id="vue的模版编译" tabindex="-1">vue的模版编译 <a class="header-anchor" href="#vue的模版编译" aria-label="Permalink to &quot;vue的模版编译&quot;">​</a></h2><p>模板字符串 -&gt; 解析器 -&gt; AST -&gt; 优化器 -&gt; AST -&gt; 代码生成器 -&gt; 渲染函数</p><h2 id="pinia和vuex" tabindex="-1">pinia和vuex <a class="header-anchor" href="#pinia和vuex" aria-label="Permalink to &quot;pinia和vuex&quot;">​</a></h2><h3 id="pinia" tabindex="-1">pinia <a class="header-anchor" href="#pinia" aria-label="Permalink to &quot;pinia&quot;">​</a></h3><ul><li>pinia专门为vue3设计开发，支持Componention API，支持TypeScript，支持类型推断，是一个轻量级的状态管理解决方案</li><li>只有state、getter、actions，可以直接使用，更加的的API，更少的规范</li><li>在不重新加载页面的情况下可以修改store，支持热模块更换</li></ul><h3 id="vuex" tabindex="-1">vuex <a class="header-anchor" href="#vuex" aria-label="Permalink to &quot;vuex&quot;">​</a></h3><ul><li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li><li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li><li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li><li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li><li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul><p><img src="https://kqd19315lhi.feishu.cn/space/api/box/stream/download/asynccode/?code=NDkyNjJhN2UwOWEzYzMxMDEzOGVmZjVjMTM4NTAzYmVfTVZPRHhMeGlrQk90VnBqelNvdnZSY3ZpbWx0QTdMbGVfVG9rZW46TUlwSGJkZVFtb0lWZE94bFFDTmNDWk1hbjZzXzE3MTU2NTY4NDA6MTcxNTY2MDQ0MF9WNA" alt="img" loading="lazy"></p><ul><li>vuex为vue2设计开发的</li><li>有state、getter、mutation、action四个，只有mutation才能变更状态，action是提交mutation。action包含异步操作</li><li>还有一个module，模块，将一些一起的都集合到一个模块，有点像vue3的Componention API</li></ul><h2 id="事件总线eventbus" tabindex="-1"><strong>事件总线EventBus</strong> <a class="header-anchor" href="#事件总线eventbus" aria-label="Permalink to &quot;**事件总线EventBus**&quot;">​</a></h2><p>基于观察者设计模式（也称为发布-订阅模式）</p><p>通过在全局创建一个事件总线，所有组件（无论他们的关系是父子还是兄弟还是不相关）都可以使用同一个总线发送事件和监听事件，传输数据。这样通信就可以不受组件间关系限制，实现灵活的通信能力。</p><h3 id="优点" tabindex="-1"><strong>优点</strong> <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;**优点**&quot;">​</a></h3><ol><li><strong>实现全局任意组件共享的数据传输</strong> 查看上面的通信方式，我们可以看到Vue提供的大部分方式都有组件关系的限制，大部分是父组件向子组件向后代组件之间传递。而事件总线却没有任何限制。</li><li><strong>实现非常简单</strong> 使用状态管理工具也可以实现数据传递，但是这些工具都要引入依赖库，有自己的使用方式。虽然并不麻烦，但是都没有事件总线使用这么简单。</li><li><strong>全局的事件管理器</strong> 组件通信除了传递数据，另一个作用是实时触发事件，针对事件进行操作。查看上面的组件通信方式，我们发现除事件总线外，全局的通信只是数据的传递，没有事件的触发。通过监听状态管理和Storage数据等，可以变相实现事件的管理，但是并没有事件总线清晰和直接。</li></ol><h3 id="缺点" tabindex="-1"><strong>缺点</strong> <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;**缺点**&quot;">​</a></h3><ul><li><strong>事件监听只能被动接收数据，不能随时获取状态</strong> 如果需要随时获取状态，显然还是状态管理工具更适合。</li><li><strong>vue3不提供事件总线能力</strong> 在vue3中$$on$$<code>off</code>等实例方法已被移除，组件实例不再实现事件触发接口。官方推荐使用 mitt 等外部工具。</li></ul><p>还有使用不慎带来的很多问题。例如：</p><ul><li><strong>事件名共享同一个命名空间</strong></li><li><strong>不销毁事件监听器</strong> 如果在不使用后忘记销毁事件监听器，会造成难以排查的Bug或者引发性能问题。</li><li><strong>误销毁同名事件其它监听器</strong> 比如多个组件都监听了同一事件&#39;add&#39;。其中某个组件销毁了&#39;add&#39;事件下的所有监听器<code>this.$EventBus.$off(&#39;add&#39;)</code>，就会影响其他的组件。</li><li><strong>其它问题</strong> 例如调试困难，耦合性高等等</li></ul><h2 id="v-if和v-for" tabindex="-1"><strong>v-if和v-for</strong> <a class="header-anchor" href="#v-if和v-for" aria-label="Permalink to &quot;**v-if和v-for**&quot;">​</a></h2><p>vue2中v-for优先</p><p>vue3中v-if优先</p><h2 id="v-if和v-show" tabindex="-1">v-if和v-show <a class="header-anchor" href="#v-if和v-show" aria-label="Permalink to &quot;v-if和v-show&quot;">​</a></h2><ul><li>v-show式给该元素添加<code>display: none</code>，dom元素依旧存在，v-if式将dom元素整个添加或删除</li><li>v-if切换有个局部编译/卸载的过程，切换过程钟合适地销毁后重构内部地事件监听和子组件，v-show只是简单的基于css切换</li><li>v-if有着更高的切换消耗，v-show有着更高地初始渲染消耗</li><li>需要非常频繁地切换，使用v-show较好，运行时条件很少变化，使用v-if更好</li></ul><h2 id="vue中的key" tabindex="-1">vue中的key <a class="header-anchor" href="#vue中的key" aria-label="Permalink to &quot;vue中的key&quot;">​</a></h2><ul><li>如果不使用key，vue就采用就地复用原则：最小化element的移动，并且会尝试尽最大成都在同适当的地方对相同类型的element，做<code>patch</code>或者<code>reuse</code></li><li>如果使用key，vue会根据keys的顺序记录element，曾经拥有了key的element如果不再出现的话，会被直接<code>remove</code>或者<code>destoryed</code></li><li>设置key能大大减少对页面的dom操作，提高diff效率</li></ul><h2 id="组件渲染和更新的过程" tabindex="-1"><strong>组件渲染和更新的过程</strong> <a class="header-anchor" href="#组件渲染和更新的过程" aria-label="Permalink to &quot;**组件渲染和更新的过程**&quot;">​</a></h2><p>初次渲染的过程</p><ul><li>解析模板为render函数</li><li>触发响应式，监听data属性getter setter</li><li>执行render函数，生成vnode，patch(elem,vnode)</li><li>执行render会触发getter</li></ul><p>更新过程</p><ul><li>修改data，触发setter</li><li>重新执行render函数，生成newVnode</li><li>patch(vnode,newVnode),diff算法会算差异</li></ul><p><img src="https://kqd19315lhi.feishu.cn/space/api/box/stream/download/asynccode/?code=MzQxYWQwNDI3NWM2ZmUwYjhjNGJmN2ZiYTI5ZDhhM2ZfZ3ZsMDk1R3FPVkJ4cE9kRWxkbDJiWU54VnpPcnE5bHJfVG9rZW46VmpVWWJRTm92b0JucER4QjBOOWNKSjZ2bkVjXzE3MTU2NTY4NDA6MTcxNTY2MDQ0MF9WNA" alt="img" loading="lazy"></p><p><img src="https://kqd19315lhi.feishu.cn/space/api/box/stream/download/asynccode/?code=M2ZmMzQzMGU3M2M0ZWUzOWQxOTVhNTJlZTBhOGNiYzBfOVVkbXQ2ZUJRVlVxbVNSOE5BTVpZemhyalg0eGVGVjJfVG9rZW46VjBMcGJQdVppb1o0aWR4clY2a2NXYVMxbnZPXzE3MTU2NTY4NDA6MTcxNTY2MDQ0MF9WNA" alt="img" loading="lazy"></p><h2 id="双向数据绑定v-model的实现原理" tabindex="-1"><strong>双向数据绑定v-model的实现原理</strong> <a class="header-anchor" href="#双向数据绑定v-model的实现原理" aria-label="Permalink to &quot;**双向数据绑定v-model的实现原理**&quot;">​</a></h2><ul><li>input元素的value=this.name</li><li>绑定input事件 this.name = $event.target.value</li><li>data 更新触发 re-render</li></ul><p>3个步骤，实现数据的双向绑定：</p><p>1.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。</p><p>2.实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。</p><p>3.实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。</p><p><img src="https://kqd19315lhi.feishu.cn/space/api/box/stream/download/asynccode/?code=MjZkMDk1NjEwMzExMjJlYmI4NmM5ZmVhM2RjYmEwYmVfZEp2cDRMN3RQcVJpUDkwM1V0UG43NERQeUVYVHR6QVBfVG9rZW46WkliMmJQN2k4bzRVY2J4Mm4zeGNOakt5bkxjXzE3MTU2NTY4NDA6MTcxNTY2MDQ0MF9WNA" alt="img" loading="lazy"></p><p><strong>vue是采用数据劫持结合发布者-订阅者模式的方式</strong>，通过**Object.defineProperty()**来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发响应的监听回调。</p><p>v-model原理其实就是给input事件绑定oninput事件 就会立刻调用底层对象对应的setter方法 改变data里的属性的值 从而实现双向数据绑定</p><p><strong>vue单项数据绑定原理</strong></p><p>单项绑定过程：变量变了，由set发通知给watcher，watcher告知虚拟DOM树，叫它该比较了，我这有值变了，于是生成新的dom树进行一个比较，然后逐级分类比较，比较出哪个元素发生变化就把这个元素更新到页面，这就是单项数据绑定原理。</p><p><img src="https://kqd19315lhi.feishu.cn/space/api/box/stream/download/asynccode/?code=YmE4MWZmMWMxN2U0NTRhMmRiNjFmOWRiODZlNWVmMDlfZDRmS2Z3YWxCNHpJSHBwbE1xSVFhb1l5WWZEWVJIUGZfVG9rZW46SHNHYWIxcEx6b1kyMU54WGJ4T2NQUnF0bkliXzE3MTU2NTY4NDA6MTcxNTY2MDQ0MF9WNA" alt="img" loading="lazy"></p><h2 id="vue从初始化页面-修改数据-刷新页面ui的过程" tabindex="-1">vue从初始化页面-修改数据-刷新页面ui的过程 <a class="header-anchor" href="#vue从初始化页面-修改数据-刷新页面ui的过程" aria-label="Permalink to &quot;vue从初始化页面-修改数据-刷新页面ui的过程&quot;">​</a></h2><p>当 Vue 进入初始化阶段时，一方面 Vue 会遍历 data 中的属性，并用 Object.defineProperty 将它转 化成 getter/setter 的形式，实现数据劫持(暂不谈 Vue3.0 的 Proxy)；另一方面，Vue 的指令编译器 Compiler 对元素节点的各个指令进行解析，初始化视图，并订阅 Watcher 来更新试图，此时 Watcher 会将自己添加到消息订阅器 Dep 中，此时初始化完毕。 当数据发生变化时，触发 Observer 中 setter 方法，立即调用 Dep.notify(),Dep 这个数组开始遍历所 有的订阅者，并调用其 update 方法，Vue 内部再通过 diff 算法，patch 相应的更新完成对订阅者视图的改变</p><h2 id="vue为什么要采用异步更新" tabindex="-1">vue为什么要采用异步更新 <a class="header-anchor" href="#vue为什么要采用异步更新" aria-label="Permalink to &quot;vue为什么要采用异步更新&quot;">​</a></h2><p>因为首先 Vue 本身是组件级更新的，更改数据如果非常多，更新非常频繁，如果不采用异步更新的话每次都需要重新渲染。</p><p>每次有数据需要更新的时候，Vue 会把它放在一个队列中，等最后的时候会调用 <code>nexttick</code> 方法。<code>nexttick</code>就会清空这个队列。</p><p>用户也可以手动调用 <code>nexttick(callback)</code> 方法，会同样把callback 回调函数放入队列中，保证视图更新完之后被调用（因为会把 callback 放进队列的最后），并且是依次链式调用。</p><h2 id="spa单页面" tabindex="-1">spa单页面 <a class="header-anchor" href="#spa单页面" aria-label="Permalink to &quot;spa单页面&quot;">​</a></h2><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p><p>优点：</p><p>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</p><p>基于上面一点，SPA 相对对服务器压力小；</p><p>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</p><p>缺点：</p><p>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</p><p>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</p><p>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</p><h2 id="keep-alive" tabindex="-1">keep-alive <a class="header-anchor" href="#keep-alive" aria-label="Permalink to &quot;keep-alive&quot;">​</a></h2><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p><ul><li>一般结合路由和动态组件一起使用，用于缓存组件；</li><li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li><li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li></ul><h2 id="vue-ssr" tabindex="-1">Vue SSR <a class="header-anchor" href="#vue-ssr" aria-label="Permalink to &quot;Vue SSR&quot;">​</a></h2><p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记&quot;激活&quot;为客户端上完全可交互的应用程序。</p><p>即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。</p><p>服务端渲染 SSR 的优缺点如下：</p><p>（1）服务端渲染的优点：</p><p>更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</p><p>更快的内容到达时间（首屏加载更快）：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</p><p>（2）服务端渲染的缺点：</p><p>更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</p><p>更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</p><h2 id="vue-router-中常用的-hash-和-history-路由模式实现原理吗" tabindex="-1"><strong>vue-router 中常用的 hash 和 history 路由模式实现原理吗？</strong> <a class="header-anchor" href="#vue-router-中常用的-hash-和-history-路由模式实现原理吗" aria-label="Permalink to &quot;**vue-router 中常用的 hash 和 history 路由模式实现原理吗？**&quot;">​</a></h2><h3 id="hash-模式的实现原理" tabindex="-1">hash 模式的实现原理 <a class="header-anchor" href="#hash-模式的实现原理" aria-label="Permalink to &quot;hash 模式的实现原理&quot;">​</a></h3><p>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为</p><p>‘#search’:<a href="https://www.word.com#search" target="_blank" rel="noreferrer">https://www.word.com#search</a></p><p>hash 路由模式的实现主要是基于下面几个特性：</p><ul><li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li><li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li><li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li><li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li></ul><h3 id="history-模式的实现原理" tabindex="-1">history 模式的实现原理 <a class="header-anchor" href="#history-模式的实现原理" aria-label="Permalink to &quot;history 模式的实现原理&quot;">​</a></h3><p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。</p><p>唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p><p>window.history.pushState(null, null, path);</p><p>window.history.replaceState(null, null, path);</p><p>history 路由模式的实现主要基于存在下面几个特性：</p><ul><li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li><li>我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li><li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li></ul><h2 id="nexttick" tabindex="-1">nextTick <a class="header-anchor" href="#nexttick" aria-label="Permalink to &quot;nextTick&quot;">​</a></h2><ol><li><code>nextTick</code>是<code>Vue</code>提供的一个全局<code>API</code>,是在下次<code>DOM</code>更新循环结束之后执行延迟回调，在修改数据之后使用<code>$nextTick</code>，则可以在回调中获取更新后的<code>DOM</code>；</li><li>Vue在更新DOM时是异步执行的。只要侦听到数据变化，<code>Vue</code>将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个<code>watcher</code>被多次触发，只会被推入到队列中-次。这种在缓冲时去除重复数据对于避免不必要的计算和<code>DOM</code>操作是非常重要的。<code>nextTick</code>方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用；</li><li>比如，我在干什么的时候就会使用nextTick，传一个回调函数进去，在里面执行dom操作即可；</li><li>我也有简单了解<code>nextTick</code>实现，它会在<code>callbacks</code>里面加入我们传入的函数，然后用<code>timerFunc</code>异步方式调用它们，首选的异步方式会是<code>Promise</code>。这让我明白了为什么可以在<code>nextTick</code>中看到<code>dom</code>操作结果。</li></ol><p><strong>原理</strong></p><p>在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。 nextTick主要使用了宏任务和微任务。 根据执行环境分别尝试采用Promise、MutationObserver、setImmediate，如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p><h2 id="vue3为什么删除时间切片" tabindex="-1">vue3为什么删除时间切片 <a class="header-anchor" href="#vue3为什么删除时间切片" aria-label="Permalink to &quot;vue3为什么删除时间切片&quot;">​</a></h2><p><a href="https://github.com/vuejs/rfcs/issues/89#issuecomment-546988615" target="_blank" rel="noreferrer">github-关于vue3删除时间切片</a></p><p>在 Web 应用程序中，“卡顿”更新通常是由同步繁重的 CPU 时间 + 原始 DOM 更新的组合引起的。时间切片是在 CPU 工作期间保持应用程序响应的一种尝试，但它<strong>仅</strong>影响CPU 工作 - DOM 更新的刷新必须仍然同步，以确保最终 DOM 状态的一致性。</p><p>因此，想象一下两种类型的卡顿更新：</p><ol><li>CPU 工作时间在 16 毫秒内，但原始 DOM 更新量巨大（例如挂载大量新 DOM 内容）。无论是否进行时间切片，该应用程序仍然会感觉“卡顿”。</li><li>CPU工作量很大，需要超过16ms。这就是时间切片理论上开始变得有益的地方 - 然而，HCI 研究表明，除非它正在制作动画，否则对于正常的用户交互，大多数人不会感觉到差异，除非更新时间超过 100 毫秒。</li><li>也就是说，只有当频繁更新需要花费超过 100 毫秒的纯 CPU 时间时，时间切片才会变得实际有益。这就是有趣的部分：这种情况在 React 中会更频繁地发生，因为 - <ol><li><em>由于重纤维架构，</em> React 的 Virtual DOM 协调本质上较慢；</li><li>与更易于静态分析的模板相比，使用 JSX 的 React 使其渲染函数本质上难以优化；</li><li>React hooks 将大部分组件树级优化（即防止子组件不必要的重新渲染）留给了开发人员，在<code>useMemo</code>大多数情况下需要显式使用。此外，每当 React 组件收到<code>children</code>prop 时，它几乎总是需要重新渲染，因为<code>children</code>每次渲染时 prop 始终是一个新鲜的 vdom 树。这意味着使用 hooks 的 React 应用程序默认会过度重新渲染。更糟糕的是，像这样的优化<code>useMemo</code>不能轻易自动应用，因为（1）它需要正确的 deps 数组，（2）盲目地在任何地方添加它可能会阻止应该发生的更新，类似于<code>PureComponent</code>。 不幸的是，大多数开发人员<strong>都</strong>很懒，不会在各处积极优化他们的应用程序，因此大多数使用钩子的 React 应用程序将执行大量不必要的 CPU 工作。</li></ol></li><li>相比之下，Vue 通过以下方式解决了上述问题： <ol><li>本质上更简单，因此更快的虚拟 DOM 协调（无时间切片 -&gt; 无纤程 -&gt; 开销更少）</li><li>通过分析模板进行大量 AOT 优化，解决虚拟 DOM 协调的基本开销。Benchmark 显示，对于动态与静态内容比例约为 1:4 的典型 DOM 内容，Vue 3 原始协调甚至比 Svelte 更快，并且在 CPU 上花费的时间不到 React 同等版本的 1/10。</li><li>通过反应性跟踪、将插槽编译为函数（避免子项导致重新渲染）和自动缓存内联处理程序（避免内联函数道具导致重新渲染）进行智能组件树级优化。除非必要，子组件永远不会重新渲染，无需开发人员进行任何手动优化。这意味着对于相同的更新，在 React 应用程序中可能会导致多个组件重新渲染，但在 Vue 中很可能只会导致 1 个组件重新渲染。</li></ol></li><li>因此，默认情况下，与 React 应用程序相比，Vue 3 应用程序花费在 CPU 上的时间要少得多，并且在 CPU 空间上花费 100+ 毫秒的机会大大减少，并且只会在极端情况下遇到，其中 DOM无论如何，这可能会成为更重要的瓶颈。</li></ol><p>现在，时间切片或并发模式带来了另一个问题：因为框架现在安排和协调所有更新，所以它在优先级、失效、重新进入等方面产生了大量额外的复杂性。处理这些的所有逻辑永远不可能是树-shaken，这会导致运行时基线大小膨胀。即使包含 Suspense 和所有可摇树的功能，Vue 3 的运行时仍然只有当前 React + React DOM 大小的 1/4。</p><p>请注意，这并不是说并发模式作为一个整体是一个坏主意。它确实提供了处理某类问题（特别是与协调异步状态转换相关）的有趣新方法，但时间切片（作为并发的子功能）专门解决了一个在 React 中比在 React 中更为突出的问题。其他框架，同时也产生了自己的成本。对于 Vue 3 来说，这种权衡似乎根本不值得。</p></div></div></main><footer class="VPDocFooter" data-v-04d3a308 data-v-cb81ca92><!--[--><!--]--><div class="edit-info" data-v-cb81ca92><div class="edit-link" data-v-cb81ca92><a class="VPLink link vp-external-link-icon no-icon edit-link-button" href="https://github.com/xiehongchen/doc/blob/master/src/前端/vue/index.md" target="_blank" rel="noreferrer" data-v-cb81ca92><!--[--><span class="vpi-square-pen edit-link-icon" data-v-cb81ca92></span> 在 GitHub 上编辑此页<!--]--></a></div><div class="last-updated" data-v-cb81ca92><p class="VPLastUpdated" data-v-cb81ca92 data-v-218c53a0>最后一次更新于: <time datetime="2024-06-05T09:52:14.000Z" data-v-218c53a0></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-cb81ca92><span class="visually-hidden" id="doc-footer-aria-label" data-v-cb81ca92>Pager</span><div class="pager" data-v-cb81ca92><!----></div><div class="pager" data-v-cb81ca92><a class="VPLink link pager-link next" href="/doc/%E5%89%8D%E7%AB%AF/vue/vue2" data-v-cb81ca92><!--[--><span class="desc" data-v-cb81ca92>下一篇</span><span class="title" data-v-cb81ca92>Vue2</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"BpQ7Oa7o\",\"其他_index.md\":\"BIlVOrXv\",\"其他_git操作.md\":\"Czv-XOEK\",\"前端_javascript_web服务器.md\":\"Cn41-R1V\",\"其他_微信jssdk接入.md\":\"DUTTU1Pd\",\"其他_支付.md\":\"ZJ5KXnAE\",\"其他_git.md\":\"DboG7GgO\",\"其他_路由.md\":\"DXejUOu9\",\"前端_javascript_特效.md\":\"C7VnuCG3\",\"其他_导出功能.md\":\"Cx_Zal65\",\"其他_搭建monorepo.md\":\"CWzNhC8E\",\"前端_javascript_对象方法.md\":\"DUaSHPIY\",\"其他_版本号排序.md\":\"oV8wdhl2\",\"前端_javascript_本地存储.md\":\"Bt8ynEl2\",\"前端_javascript_函数柯里化.md\":\"DuST3iS8\",\"前端_javascript_数组方法.md\":\"CIC_Lxzv\",\"其他_下载.md\":\"Gx-R91NC\",\"其他_禁止下拉.md\":\"C645DV0L\",\"前端_javascript_并发控制.md\":\"B-DSsSrb\",\"其他_关于时间的处理_date对象.md\":\"B638f-mg\",\"其他_视频文件修改md5值.md\":\"DoJJtGtX\",\"前端_javascript_es6.md\":\"GpqLZq6w\",\"前端_css_css学习.md\":\"DSRbr4Ug\",\"前端_javascript_symbol.md\":\"SQr3IzAd\",\"前端_index.md\":\"DCExtda2\",\"前端_javascript_隐式转换.md\":\"BUXj8ugN\",\"其他_文件上传后缀名与文件类型对照表.md\":\"9o6Y1p0z\",\"前端_html_index.md\":\"V4fpPvX8\",\"前端_css_index.md\":\"DE1lHdDF\",\"前端_javascript_移动端.md\":\"D-hWoQpL\",\"前端_javascript_index.md\":\"CF34Z9bS\",\"其他_webpack5.md\":\"CR4T3C5U\",\"前端_javascript_javascript进阶dom和bom.md\":\"KoGSE6TM\",\"前端_javascript_数据可视化.md\":\"DV3MJ7hw\",\"前端_react_index.md\":\"Dtk5_fQi\",\"前端_vue_vue3_1、创建vue3.0工程.md\":\"WUnK9zBi\",\"前端_javascript_javascript基础.md\":\"CslB-IYG\",\"前端_typescript_index.md\":\"CNDoaS4e\",\"前端_javascript_promise.md\":\"De6L7KK2\",\"前端_vue_vue3_3、其它 composition api.md\":\"Cmq4n1vh\",\"test.md\":\"B2a_Mp0k\",\"其他_判断平台.md\":\"CtYVxC6H\",\"算法_华为机考_5键键盘.md\":\"L2JAxIb-\",\"其他_前端学习.md\":\"DI2fD-ZN\",\"算法_index.md\":\"Dtac0H9c\",\"算法_leetcode_10、h-正则表达式匹配.md\":\"lCB1OThm\",\"算法_leetcode_11、m-盛最多水的容器.md\":\"1g1q-de-\",\"算法_leetcode_1071、e-字符串的最大公因子.md\":\"CaeR8IXu\",\"算法_leetcode_1111、m-有效括号的嵌套深度.md\":\"CE1lgJnB\",\"算法_leetcode_13、e-罗马数字转整数.md\":\"DH6JOKbn\",\"算法_leetcode_1480、e-一维数组的动态和.md\":\"DGZ5prS5\",\"算法_leetcode_14、e-最长公共前缀.md\":\"esDGQzHx\",\"前端_vue_vue3_6、其他.md\":\"CrFoiOe5\",\"算法_leetcode_1507、e-转变日期格式.md\":\"BQH0GhFa\",\"算法_leetcode_151、m-反转字符串中的单词.md\":\"CplpRPA_\",\"算法_leetcode_1556、e-千位分隔符.md\":\"Bgl5W3iQ\",\"算法_leetcode_169、e-多数元素.md\":\"Cgr2kpch\",\"算法_leetcode_189、m-轮转数组.md\":\"CBP5YfzB\",\"算法_leetcode_20、e-有效的括号.md\":\"D3iZKnIG\",\"算法_leetcode_1、e-两数之和.md\":\"CHgezoVe\",\"算法_leetcode_2047、e-句子中的有效单词数.md\":\"BU52PZmT\",\"算法_leetcode_21、e-合并俩个有序链表.md\":\"Bb8SxO0H\",\"算法_leetcode_26、e-删除有序数组中的重复项.md\":\"B96SpFQe\",\"算法_leetcode_27、e-移除元素.md\":\"CM8m3ab8\",\"算法_leetcode_205、e-同构字符串.md\":\"sIVhSyBQ\",\"算法_leetcode_2、m-两数相加.md\":\"CXl2OANK\",\"算法_leetcode_3、m-无重复字符的最长字串.md\":\"Blp5JVBe\",\"算法_leetcode_581.最短无序连续子数组.md\":\"CpSndw0e\",\"算法_leetcode_4、h-寻找两个正序数组的中位数.md\":\"COtP9VfF\",\"算法_leetcode_5、m-最长回文字串.md\":\"BwQNY6Cj\",\"算法_leetcode_80、m-删除有序数据中的重复项.md\":\"C2bDiSy6\",\"算法_leetcode_9、e-回文数.md\":\"BCRNP-Nn\",\"算法_leetcode_724、e-寻找数组的中心下标.md\":\"Dt21-QZl\",\"算法_leetcode_88、e-合并两个有序数组.md\":\"D9ePzCoQ\",\"算法_冒泡排序.md\":\"VENnVUO0\",\"算法_华为机考_hj10-e-字符个数统计.md\":\"BFvwQMf_\",\"算法_华为机考_hj100-e-等差数列.md\":\"B7d3_5ws\",\"算法_华为机考_按单词下标区间翻转文章内容.md\":\"tpLxo3b5\",\"算法_华为机考_hj40-e-统计字符.md\":\"DHaMdNQz\",\"算法_华为机考_hj5-e-进制转换.md\":\"lIfqr1ex\",\"算法_华为机考_hj60-e-查找组成一个偶数最接近的两个素数.md\":\"DiS99vo6\",\"算法_华为机考_hj75-m-公共子串计算.md\":\"CX0Bo5sV\",\"算法_华为机考_hj81-e-字符串字符匹配.md\":\"DDGJ6Eub\",\"算法_华为机考_hj58-e-输入n个整数，输出其中最小的k个.md\":\"DXanccTH\",\"算法_华为机考_hj59-m-找出字符串中第一个只出现一次的字符.md\":\"DhWdUeEY\",\"算法_华为机考_hj86-e-求最大连续bit数.md\":\"VDuH6Mrm\",\"算法_华为机考_乱序整数序列两数之和绝对值最小.md\":\"deomCF4p\",\"算法_华为机考_判断是不是子字符串.md\":\"DZUj38eV\",\"算法_华为机考_多个数组按顺序合并.md\":\"DmJQXsSM\",\"算法_华为机考_字符串加密.md\":\"CUoWA4o-\",\"前端_javascript_jquery.md\":\"DPYADOQf\",\"算法_华为机考_射击比赛.md\":\"GKRe1Q26\",\"算法_华为机考_括号检查.md\":\"y2dUcuA-\",\"面试题_index.md\":\"lhnr10Ty\",\"算法_华为机考_尼科彻斯定理.md\":\"BPwtdgg0\",\"算法_华为机考_分积木.md\":\"BcbMVp5T\",\"算法_华为机考_整数对最小和.md\":\"B9PJ3ttY\",\"算法_华为机考_求字符串中所有整数的最小和.md\":\"DTZX1wQt\",\"前端_vue_vue3_5、新的组件.md\":\"lsMA1-JT\",\"算法_华为机考_组成最大数.md\":\"CtfOHMGw\",\"算法_华为机考_检查是否存在满足条件的数字组合.md\":\"DGWlGW8Y\",\"算法_快速排序.md\":\"BumpxpDn\",\"面试题_浏览器.md\":\"CpurZ1G4\",\"前端_javascript_javascript面向对象.md\":\"m3iioUJ-\",\"前端_vue_vue3_4、composition api 的优势.md\":\"Cx0RVO4j\",\"前端_vue_vue3_2、常用 composition api.md\":\"CytgBiKB\",\"其他_文件格式.md\":\"DghAi06G\",\"算法_leetcode_121、e-买卖股票的最佳时机.md\":\"fVv7RU2i\",\"算法_leetcode_392、e-判断子序列.md\":\"Cb0D-cer\",\"面试题_vue.md\":\"P46VNDBo\",\"算法_华为机考_hj85-e-最长回文子串.md\":\"DKE6AAAF\",\"算法_华为机考_非严格递增连续数字序列.md\":\"CB5G8V6N\",\"面试题_计算机网络.md\":\"CZuanRBd\",\"算法_插入排序.md\":\"BFAsUmdP\",\"算法_选择排序.md\":\"Bujsk9Ds\",\"面试题_javascript.md\":\"CIv9WiJj\",\"面试题_react.md\":\"CzDPKwXP\",\"前端_vue_vue3.md\":\"C7oFDv6p\",\"前端_vue_index.md\":\"Cp3HWG8L\",\"后端_index.md\":\"CADa5y4s\",\"后端_java_jdbc.md\":\"Do9e946Y\",\"后端_node_express.md\":\"jeI9t3yX\",\"面试题_html_css.md\":\"CUX5AU-l\",\"前端_vue_vue2.md\":\"CMFBSps6\",\"后端_java_mysql.md\":\"C8gMyWww\",\"后端_node_index.md\":\"DLtS_EeU\",\"前端_javascript_canvas.md\":\"DIUrFfEE\",\"后端_java_index.md\":\"DG5JZQ5L\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"xiehongchen\",\"titleTemplate\":\"记录学习过程的问题\",\"description\":\"基于 VitePress 构建的个人博客网站\",\"base\":\"/doc/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"siteTitle\":\"xiehongchen\",\"logo\":\"/logo.jpeg\",\"search\":{\"provider\":\"local\",\"options\":{\"locales\":{\"zh\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\"}}}}}}},\"outline\":\"deep\",\"outlineTitle\":\"当前页导航\",\"docFooter\":{\"prev\":\"上一篇\",\"next\":\"下一篇\"},\"nav\":[{\"text\":\"前端基础\",\"items\":[{\"text\":\"HTML\",\"link\":\"/前端/html/\"},{\"text\":\"CSS\",\"link\":\"/前端/css/\"},{\"text\":\"JavaScript\",\"link\":\"/前端/javascript/\"}]},{\"text\":\"前端进阶\",\"items\":[{\"text\":\"TypeScript\",\"link\":\"/前端/typescript/\"},{\"text\":\"Vue\",\"link\":\"/前端/vue/\"},{\"text\":\"React\",\"link\":\"/前端/react/\"}]},{\"text\":\"其他\",\"link\":\"/其他\"},{\"text\":\"算法\",\"link\":\"/算法\"},{\"text\":\"后端\",\"items\":[{\"text\":\"Node\",\"link\":\"/后端/node/\"},{\"text\":\"Java\",\"link\":\"/后端/java/\"}]}],\"sidebar\":{\"/面试题/\":[{\"text\":\"index\",\"link\":\"/面试题/index.md\"},{\"text\":\"html&css\",\"link\":\"/面试题/html&css.md\"},{\"text\":\"javascript\",\"link\":\"/面试题/javascript.md\"},{\"text\":\"react\",\"link\":\"/面试题/react.md\"},{\"text\":\"vue\",\"link\":\"/面试题/vue.md\"},{\"text\":\"浏览器\",\"link\":\"/面试题/浏览器.md\"},{\"text\":\"计算机网络\",\"link\":\"/面试题/计算机网络.md\"}],\"/前端/html/\":[{\"text\":\"HTML\",\"link\":\"/前端/html/index.md\"}],\"/前端/css/\":[{\"text\":\"CSS\",\"link\":\"/前端/css/index.md\"},{\"text\":\"css学习\",\"link\":\"/前端/css/css学习.md\"}],\"/前端/javascript/\":[{\"text\":\"javascript\",\"link\":\"/前端/javascript/index.md\"},{\"text\":\"JavaScript基础\",\"link\":\"/前端/javascript/JavaScript基础\"},{\"text\":\"ES6\",\"link\":\"/前端/javascript/ES6.md\"},{\"text\":\"JavaScript进阶dom和bom\",\"link\":\"/前端/javascript/JavaScript进阶dom和bom.md\"},{\"text\":\"JavaScript面向对象\",\"link\":\"/前端/javascript/JavaScript面向对象.md\"},{\"text\":\"jQuery\",\"link\":\"/前端/javascript/jQuery.md\"},{\"text\":\"symbol\",\"link\":\"/前端/javascript/symbol.md\"},{\"text\":\"web服务器\",\"link\":\"/前端/javascript/web服务器.md\"},{\"text\":\"数据可视化\",\"link\":\"/前端/javascript/数据可视化.md\"},{\"text\":\"本地存储\",\"link\":\"/前端/javascript/本地存储.md\"},{\"text\":\"特效\",\"link\":\"/前端/javascript/特效.md\"},{\"text\":\"移动端\",\"link\":\"/前端/javascript/移动端.md\"},{\"text\":\"promise\",\"link\":\"/前端/javascript/promise.md\"},{\"text\":\"canvas\",\"link\":\"/前端/javascript/canvas.md\"},{\"text\":\"并发控制\",\"link\":\"/前端/javascript/并发控制.md\"},{\"text\":\"对象方法\",\"link\":\"/前端/javascript/对象方法.md\"},{\"text\":\"数组方法\",\"link\":\"/前端/javascript/数组方法.md\"},{\"text\":\"函数柯里化\",\"link\":\"/前端/javascript/函数柯里化.md\"},{\"text\":\"隐式转换\",\"link\":\"/前端/javascript/隐式转换.md\"}],\"/前端/typescript/\":[{\"text\":\"typescript\",\"link\":\"/前端/typescript/index.md\"}],\"/前端/vue/\":[{\"text\":\"vue\",\"link\":\"/前端/vue/index.md\"},{\"text\":\"Vue2\",\"link\":\"/前端/vue/vue2.md\"},{\"text\":\"Vue3\",\"collapsed\":true,\"items\":[{\"text\":\"1、创建Vue3.0工程\",\"link\":\"/前端/vue/vue3/1、创建Vue3.0工程.md\"},{\"text\":\"2、常用 Composition API\",\"link\":\"/前端/vue/vue3/2、常用 Composition API.md\"},{\"text\":\"3、其它 Composition API\",\"link\":\"/前端/vue/vue3/3、其它 Composition API.md\"},{\"text\":\"4、Composition API 的优势\",\"link\":\"/前端/vue/vue3/4、Composition API 的优势.md\"},{\"text\":\"5、新的组件\",\"link\":\"/前端/vue/vue3/5、新的组件.md\"},{\"text\":\"6、其他\",\"link\":\"/前端/vue/vue3/6、其他.md\"}]}],\"/前端/react/\":[{\"text\":\"React\",\"link\":\"/前端/react/index.md\"}],\"/后端/node/\":[{\"text\":\"node\",\"link\":\"/后端/node/index.md\"},{\"text\":\"express\",\"link\":\"/后端/node/express.md\"}],\"/后端/java/\":[{\"text\":\"java\",\"link\":\"/后端/java/index.md\"},{\"text\":\"jdbc\",\"link\":\"/后端/java/JDBC.md\"},{\"text\":\"mysql\",\"link\":\"/后端/java/MYSQL.md\"}],\"/其他/\":[{\"text\":\"其他\",\"link\":\"/其他/index.md\"},{\"text\":\"前端学习\",\"link\":\"/其他/前端学习.md\"},{\"text\":\"git\",\"link\":\"/其他/git.md\"},{\"text\":\"git操作\",\"link\":\"/其他/git操作.md\"},{\"text\":\"webpack5\",\"link\":\"/其他/webpack5.md\"},{\"text\":\"下载\",\"link\":\"/其他/下载.md\"},{\"text\":\"关于时间的处理&Date对象\",\"link\":\"/其他/关于时间的处理&Date对象.md\"},{\"text\":\"判断平台\",\"link\":\"/其他/判断平台.md\"},{\"text\":\"导出功能\",\"link\":\"/其他/导出功能.md\"},{\"text\":\"微信jssdk接入\",\"link\":\"/其他/微信jssdk接入.md\"},{\"text\":\"搭建Monorepo\",\"link\":\"/其他/搭建Monorepo.md\"},{\"text\":\"支付\",\"link\":\"/其他/支付.md\"},{\"text\":\"文件上传后缀名与文件类型对照表\",\"link\":\"/其他/文件上传后缀名与文件类型对照表.md\"},{\"text\":\"文件格式\",\"link\":\"/其他/文件格式.md\"},{\"text\":\"版本号排序\",\"link\":\"/其他/版本号排序.md\"},{\"text\":\"禁止下拉\",\"link\":\"/其他/禁止下拉.md\"},{\"text\":\"视频文件修改md5值\",\"link\":\"/其他/视频文件修改md5值.md\"},{\"text\":\"路由\",\"link\":\"/其他/路由.md\"}],\"/算法/\":[{\"text\":\"算法\",\"link\":\"/算法/index.md\"},{\"text\":\"插入排序\",\"link\":\"/算法/插入排序.md\"},{\"text\":\"快速排序\",\"link\":\"/算法/快速排序.md\"},{\"text\":\"冒泡排序\",\"link\":\"/算法/冒泡排序.md\"},{\"text\":\"选择排序\",\"link\":\"/算法/选择排序.md\"},{\"text\":\"华为机考\",\"collapsed\":true,\"items\":[{\"text\":\"HJ5-E-进制转换\",\"link\":\"/算法/华为机考/HJ5-E-进制转换.md\"},{\"text\":\"HJ10-E-字符个数统计\",\"link\":\"/算法/华为机考/HJ10-E-字符个数统计.md\"},{\"text\":\"HJ40-E-统计字符\",\"link\":\"/算法/华为机考/HJ40-E-统计字符.md\"},{\"text\":\"HJ58-E-输入n个整数，输出其中最小的k个\",\"link\":\"/算法/华为机考/HJ58-E-输入n个整数，输出其中最小的k个.md\"},{\"text\":\"HJ59-M-找出字符串中第一个只出现一次的字符\",\"link\":\"/算法/华为机考/HJ59-M-找出字符串中第一个只出现一次的字符.md\"},{\"text\":\"HJ60-E-查找组成一个偶数最接近的两个素数\",\"link\":\"/算法/华为机考/HJ60-E-查找组成一个偶数最接近的两个素数.md\"},{\"text\":\"HJ75-M-公共子串计算\",\"link\":\"/算法/华为机考/HJ75-M-公共子串计算.md\"},{\"text\":\"HJ81-E-字符串字符匹配\",\"link\":\"/算法/华为机考/HJ81-E-字符串字符匹配.md\"},{\"text\":\"HJ85-E-最长回文子串\",\"link\":\"/算法/华为机考/HJ85-E-最长回文子串.md\"},{\"text\":\"HJ86-E-求最大连续bit数\",\"link\":\"/算法/华为机考/HJ86-E-求最大连续bit数.md\"},{\"text\":\"HJ100-E-等差数列\",\"link\":\"/算法/华为机考/HJ100-E-等差数列.md\"},{\"text\":\"5键键盘\",\"link\":\"/算法/华为机考/5键键盘.md\"},{\"text\":\"乱序整数序列两数之和绝对值最小\",\"link\":\"/算法/华为机考/乱序整数序列两数之和绝对值最小.md\"},{\"text\":\"分积木\",\"link\":\"/算法/华为机考/分积木.md\"},{\"text\":\"判断是不是子字符串\",\"link\":\"/算法/华为机考/判断是不是子字符串.md\"},{\"text\":\"多个数组按顺序合并\",\"link\":\"/算法/华为机考/多个数组按顺序合并.md\"},{\"text\":\"字符串加密\",\"link\":\"/算法/华为机考/字符串加密.md\"},{\"text\":\"射击比赛\",\"link\":\"/算法/华为机考/射击比赛.md\"},{\"text\":\"尼科彻斯定理\",\"link\":\"/算法/华为机考/尼科彻斯定理.md\"},{\"text\":\"括号检查\",\"link\":\"/算法/华为机考/括号检查.md\"},{\"text\":\"按单词下标区间翻转文章内容\",\"link\":\"/算法/华为机考/按单词下标区间翻转文章内容.md\"},{\"text\":\"整数对最小和\",\"link\":\"/算法/华为机考/整数对最小和.md\"},{\"text\":\"检查是否存在满足条件的数字组合\",\"link\":\"/算法/华为机考/检查是否存在满足条件的数字组合.md\"},{\"text\":\"求字符串中所有整数的最小和\",\"link\":\"/算法/华为机考/求字符串中所有整数的最小和.md\"},{\"text\":\"组成最大数\",\"link\":\"/算法/华为机考/组成最大数.md\"},{\"text\":\"非严格递增连续数字序列\",\"link\":\"/算法/华为机考/非严格递增连续数字序列.md\"}]},{\"text\":\"leetcode\",\"collapsed\":true,\"items\":[{\"text\":\"1、E-两数之和\",\"link\":\"/算法/leetcode/1、E-两数之和.md\"},{\"text\":\"2、M-两数相加\",\"link\":\"/算法/leetcode/2、M-两数相加.md\"},{\"text\":\"3、M-无重复字符的最长字串\",\"link\":\"/算法/leetcode/3、M-无重复字符的最长字串.md\"},{\"text\":\"4、H-寻找两个正序数组的中位数\",\"link\":\"/算法/leetcode/4、H-寻找两个正序数组的中位数.md\"},{\"text\":\"5、M-最长回文字串\",\"link\":\"/算法/leetcode/5、M-最长回文字串.md\"},{\"text\":\"9、E-回文数\",\"link\":\"/算法/leetcode/9、E-回文数.md\"},{\"text\":\"10、H-正则表达式匹配\",\"link\":\"/算法/leetcode/10、H-正则表达式匹配.md\"},{\"text\":\"11、M-盛最多水的容器\",\"link\":\"/算法/leetcode/11、M-盛最多水的容器.md\"},{\"text\":\"13、E-罗马数字转整数\",\"link\":\"/算法/leetcode/13、E-罗马数字转整数.md\"},{\"text\":\"14、E-最长公共前缀\",\"link\":\"/算法/leetcode/14、E-最长公共前缀.md\"},{\"text\":\"20、E-有效的括号\",\"link\":\"/算法/leetcode/20、E-有效的括号.md\"},{\"text\":\"21、E-合并俩个有序链表\",\"link\":\"/算法/leetcode/21、E-合并俩个有序链表.md\"},{\"text\":\"26、E-删除有序数组中的重复项\",\"link\":\"/算法/leetcode/26、E-删除有序数组中的重复项.md\"},{\"text\":\"27、E-移除元素\",\"link\":\"/算法/leetcode/27、E-移除元素.md\"},{\"text\":\"80、M-删除有序数据中的重复项\",\"link\":\"/算法/leetcode/80、M-删除有序数据中的重复项.md\"},{\"text\":\"88、E-合并两个有序数组\",\"link\":\"/算法/leetcode/88、E-合并两个有序数组.md\"},{\"text\":\"121、E-买卖股票的最佳时机\",\"link\":\"/算法/leetcode/121、E-买卖股票的最佳时机.md\"},{\"text\":\"151、M-反转字符串中的单词\",\"link\":\"/算法/leetcode/151、M-反转字符串中的单词.md\"},{\"text\":\"169、E-多数元素\",\"link\":\"/算法/leetcode/169、E-多数元素.md\"},{\"text\":\"189、M-轮转数组\",\"link\":\"/算法/leetcode/189、M-轮转数组.md\"},{\"text\":\"205、E-同构字符串\",\"link\":\"/算法/leetcode/205、E-同构字符串.md\"},{\"text\":\"392、E-判断子序列\",\"link\":\"/算法/leetcode/392、E-判断子序列.md\"},{\"text\":\"724、E-寻找数组的中心下标\",\"link\":\"/算法/leetcode/724、E-寻找数组的中心下标.md\"},{\"text\":\"1071、E-字符串的最大公因子\",\"link\":\"/算法/leetcode/1071、E-字符串的最大公因子.md\"},{\"text\":\"1111、M-有效括号的嵌套深度\",\"link\":\"/算法/leetcode/1111、M-有效括号的嵌套深度.md\"},{\"text\":\"1480、E-一维数组的动态和\",\"link\":\"/算法/leetcode/1480、E-一维数组的动态和.md\"},{\"text\":\"1507、E-转变日期格式\",\"link\":\"/算法/leetcode/1507、E-转变日期格式.md\"},{\"text\":\"1556、E-千位分隔符\",\"link\":\"/算法/leetcode/1556、E-千位分隔符.md\"},{\"text\":\"2047、E-句子中的有效单词数\",\"link\":\"/算法/leetcode/2047、E-句子中的有效单词数.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/xiehongchen\"}],\"editLink\":{\"pattern\":\"https://github.com/xiehongchen/doc/blob/master/src/:path\",\"text\":\"在 GitHub 上编辑此页\"},\"lastUpdatedText\":\"最后一次更新于\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":true}");</script>
    
  </body>
</html>